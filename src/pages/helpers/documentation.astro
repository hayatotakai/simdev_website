---
import Layout from '../../layouts/readmeViewer.astro';
---

<Layout>
<style>
/* Layout */
.doc-layout {
  display: block;
}

.toc-sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 420px;
  height: 100vh;
  overflow-y: auto;
  padding: 20px 16px;
  border-right: 1px solid rgba(175, 184, 193, 0.4);
  background-color: #ffffff;
  box-sizing: border-box;
}

.toc-title {
  font-weight: 600;
  font-size: 14px;
  margin: 0 0 1px 0;
  color: #1f2328;
}

.toc-list {
  list-style: none;
  padding: 0;
  margin: 0;
  font-size: 13px;
}

.toc-list ul {
  list-style: none;
  padding-left: 16px;
  margin: 4px 0;
}

.toc-list li {
  margin: 4px 0;
  line-height: 1.4;
}

.toc-list a {
  color: #0969da;
  text-decoration: none;
  display: block;
  padding: 2px 0;
  font-size: 13px;
}

.toc-list a:hover {
  text-decoration: underline;
}

.toc-list > li > a {
  font-weight: 600;
}

.doc-content {
  margin-left: 280px;
}

@media (max-width: 900px) {
  .toc-sidebar {
    position: static;
    width: 100%;
    height: auto;
    border-right: none;
    border-bottom: 1px solid rgba(175, 184, 193, 0.4);
  }

  .doc-content {
    margin-left: 0;
  }
}

/* Code block styling */
/* Code block styling */
.markdown-body pre {
  background-color: #818181;
  border-radius: 6px;
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
}

.markdown-body code {
  background-color: rgba(175, 184, 193, 0.2);
  border-radius: 6px;
  padding: 0.2em 0.4em;
  font-size: 85%;
}

.markdown-body pre code {
  background-color: transparent;
  padding: 0;
  border-radius: 0;
  font-size: 100%;
}

/* GitHub API syntax highlighting styles */
.markdown-body .highlight pre,
.markdown-body pre.notranslate {
  background-color: #f6f8fa;
}

/* Dark mode code blocks */
@media (prefers-color-scheme: dark) {
  .markdown-body pre,
  .markdown-body .highlight pre,
  .markdown-body pre.notranslate {
    background-color: #161b22;
  }
  
  .markdown-body code {
    background-color: rgba(110, 118, 129, 0.4);
  }
  
  .markdown-body pre code {
    background-color: transparent;
  }
  .markdown-body .highlight {
    background-color: rgba(110, 118, 129, 0.4);
  }
  
}

</style>

<div class="doc-layout">
  <aside class="toc-sidebar" aria-label="Table of contents">
    <div class="toc-title">Contents</div>
    <ul id="tocList" class="toc-list"></ul>
  </aside>

  <div class="markdown-body doc-content" style="max-width: 900px; margin: 0 auto; padding: 20px;">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
    <h1 id="pageTitle">README</h1>
    <button id="backBtn" class="back-button" style="padding: 8px 16px; background-color: #0969da; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">‚Üê Back</button>
  </div>

  <div id="loadingSpinner" class="loading">Loading README...</div>
  <div id="readmeContent" style="display: none;"></div>
  <div id="errorMessage" class="error-message" style="display: none;"></div>
  </div>
</div>

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    },
    startup: {
      typeset: false
    }
  };
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" ></script>

<script is:inline>
  // Get the readme path from URL query parameter
  const urlParams = new URLSearchParams(window.location.search);
  const readmeParam = urlParams.get('readme') || urlParams.get('file');
  const defaultReadme = '/scripts/oil_properties/README.md';

  function normalizeReadmePath(input) {
    if (!input) return defaultReadme;
    const decoded = decodeURIComponent(input);
    if (/^https?:\/\//i.test(decoded)) {
      throw new Error('External URLs are not allowed.');
    }
    if (decoded.includes('..')) {
      throw new Error('Invalid path.');
    }
    if (decoded.startsWith('/')) return decoded;
    return `/${decoded}`;
  }

  let readmePath = defaultReadme;
  try {
    readmePath = normalizeReadmePath(readmeParam);
  } catch (err) {
    console.warn(err.message);
  }

  function waitForMathJax() {
    if (window.MathJax && window.MathJax.typesetPromise) {
      if (window.MathJax.startup && window.MathJax.startup.promise) {
        return window.MathJax.startup.promise;
      }
      return Promise.resolve();
    }

    const mjScript = document.querySelector('script[src*="mathjax@3"]');
    return new Promise((resolve) => {
      if (mjScript) {
        mjScript.addEventListener('load', () => resolve(), { once: true });
      } else {
        resolve();
      }
    }).then(() => {
      if (window.MathJax && window.MathJax.typesetPromise) {
        if (window.MathJax.startup && window.MathJax.startup.promise) {
          return window.MathJax.startup.promise;
        }
        return Promise.resolve();
      }
      return new Promise((resolve) => setTimeout(resolve, 0));
    });
  }

  async function loadReadme() {
    const loading = document.getElementById('loadingSpinner');
    const content = document.getElementById('readmeContent');
    const error = document.getElementById('errorMessage');
    const title = document.getElementById('pageTitle');
    const tocList = document.getElementById('tocList');

    try {
      // Fetch the markdown file
      const response = await fetch(readmePath);
      if (!response.ok) {
        throw new Error(`Failed to load ${readmePath}: ${response.statusText}`);
      }

      let markdown = await response.text();
      
      if (!markdown || typeof markdown !== 'string') {
        throw new Error('README file is empty or invalid');
      }

      // Extract title from first h1
      const titleMatch = markdown.match(/^# (.+)$/m);
      if (titleMatch) {
        title.textContent = titleMatch[1];
      }

      // Convert markdown to HTML using GitHub API
      const apiResponse = await fetch('https://api.github.com/markdown', {
        method: 'POST',
        headers: {
          'Accept': 'application/vnd.github+json',
          'Content-Type': 'application/json',
          'X-GitHub-Api-Version': '2022-11-28'
        },
        body: JSON.stringify({
          text: markdown,
          mode: 'gfm'
        })
      });

      if (!apiResponse.ok) {
        throw new Error(`GitHub API error: ${apiResponse.statusText}`);
      }

      let html = await apiResponse.text();

      content.innerHTML = html;
      content.style.display = 'block';
      loading.style.display = 'none';

      // Build hierarchical table of contents from rendered headings
      if (tocList) {
        tocList.innerHTML = '';
        const headings = content.querySelectorAll('h1, h2, h3, h4, h5, h6');
        const usedIds = new Map();

        const slugify = (text) => text
          .toLowerCase()
          .trim()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-');

        // Add IDs to headings
        headings.forEach((heading) => {
          if (!heading.id) {
            const base = slugify(heading.textContent || 'section');
            const count = usedIds.get(base) || 0;
            const id = count ? `${base}-${count}` : base;
            usedIds.set(base, count + 1);
            heading.id = id;
          }
        });

        // Build hierarchical structure
        let currentList = tocList;
        let currentLevel = 0;
        const listStack = [{ list: tocList, level: 0 }];
        
        headings.forEach((heading) => {
          const level = Number(heading.tagName.replace('H', ''));
          const li = document.createElement('li');
          const a = document.createElement('a');
          a.href = `#${heading.id}`;
          a.textContent = heading.textContent || '';
          li.appendChild(a);

          // Pop stack until we find the appropriate parent level
          while (listStack.length > 0 && listStack[listStack.length - 1].level >= level) {
            listStack.pop();
          }

          // Get the parent list
          const parentItem = listStack[listStack.length - 1];
          
          if (level > parentItem.level) {
            // Need to nest - find or create nested ul in last li of parent list
            const lastLi = parentItem.list.lastElementChild;
            let nestedUl;
            
            if (lastLi && lastLi.tagName === 'LI') {
              nestedUl = lastLi.querySelector(':scope > ul');
              if (!nestedUl) {
                nestedUl = document.createElement('ul');
                lastLi.appendChild(nestedUl);
              }
            } else {
              // No previous li, append to parent list
              nestedUl = document.createElement('ul');
              parentItem.list.appendChild(nestedUl);
            }
            
            nestedUl.appendChild(li);
            listStack.push({ list: nestedUl, level });
          } else {
            // Same level - append to parent list
            parentItem.list.appendChild(li);
            listStack.push({ list: parentItem.list, level });
          }
        });
      }

      // Render MathJax when ready
      await waitForMathJax();
      if (window.MathJax && window.MathJax.typesetPromise) {
        if (window.MathJax.typesetClear) {
          MathJax.typesetClear([content]);
        }
        MathJax.typesetPromise([content]).catch(err => console.log('MathJax render error:', err));
      }
    } catch (err) {
      error.textContent = `Error loading README: ${err.message}`;
      error.style.display = 'block';
      loading.style.display = 'none';
      console.error('README loader error:', err);
    }
  }

  // Load readme when page loads
  document.addEventListener('DOMContentLoaded', loadReadme);

  // Back button handler
  const backBtn = document.getElementById('backBtn');
  if (backBtn) {
    backBtn.addEventListener('click', () => {
      if (window.history.length > 1) {
        window.history.back();
      } else {
        // If no history, go to home or tools page
        window.location.href = '/tools/oil_properties';
      }
    });
  }
</script>

</Layout>
